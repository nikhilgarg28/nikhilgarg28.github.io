<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Introducing Delegate</title>
  <meta name="description"
    content="Multi-agent software engineering with configurable workflows. Local-first, browser-based, open source.">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Source+Serif+4:ital,opsz,wght@0,8..60,300;0,8..60,400;0,8..60,600;1,8..60,400&display=swap"
    rel="stylesheet">
  <style>
    :root {
      --bg: #141415;
      --surface: #1a1a1c;
      --surface-2: #222224;
      --border: #2a2a2d;
      --text: #cccccd;
      --text-dim: #858587;
      --green: #4ade80;
      --green-dim: #4ade8033;
      --amber: #fbbf24;
      --red: #f87171;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'Source Serif 4', Georgia, serif;
      font-size: 18px;
      line-height: 1.72;
      -webkit-font-smoothing: antialiased;
    }

    .container {
      max-width: 720px;
      margin: 0 auto;
      padding: 80px 24px 120px;
    }

    .logo {
      font-family: 'JetBrains Mono', monospace;
      font-size: 20px;
      font-weight: 500;
      color: var(--green);
      margin-bottom: 64px;
      letter-spacing: -0.02em;
    }

    .logo .chevron {
      opacity: 0.5;
    }

    h1 {
      font-family: 'Source Serif 4', Georgia, serif;
      font-size: 40px;
      font-weight: 600;
      line-height: 1.2;
      color: #eee;
      margin-bottom: 16px;
      letter-spacing: -0.02em;
    }

    .subtitle {
      font-size: 20px;
      color: var(--text-dim);
      margin-bottom: 64px;
      line-height: 1.5;
    }

    .date {
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      color: var(--text-dim);
      margin-bottom: 48px;
    }

    h2 {
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      font-weight: 600;
      color: var(--green);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-top: 72px;
      margin-bottom: 24px;
    }

    p {
      margin-bottom: 24px;
    }

    a {
      color: var(--green);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    strong {
      color: #eee;
      font-weight: 600;
    }

    code {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85em;
      background: var(--surface-2);
      padding: 2px 7px;
      border-radius: 4px;
    }

    pre {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 20px 24px;
      margin: 28px 0;
      overflow-x: auto;
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      line-height: 1.6;
      color: var(--text-dim);
    }

    pre strong {
      color: var(--text);
      font-weight: 400;
    }

    hr {
      border: none;
      border-top: 1px solid var(--border);
      margin: 64px 0;
    }

    .phases {
      display: flex;
      flex-direction: column;
      gap: 0;
      margin: 40px 0;
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
    }

    .phase {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 14px 20px;
      border-left: 2px solid var(--border);
      position: relative;
    }

    .phase:last-child {
      border-left-color: var(--green);
    }

    .phase-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--border);
      flex-shrink: 0;
      position: absolute;
      left: -5px;
    }

    .phase:last-child .phase-dot {
      background: var(--green);
      box-shadow: 0 0 8px var(--green-dim);
    }

    .phase-label {
      color: var(--text-dim);
      min-width: 200px;
    }

    .phase:last-child .phase-label {
      color: var(--green);
    }

    .phase-form {
      color: var(--text-dim);
      opacity: 0.5;
    }

    .phase:last-child .phase-form {
      color: var(--text);
      opacity: 1;
    }

    .workflow-diagram {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 32px 24px;
      margin: 32px 0;
      overflow-x: auto;
    }

    .workflow-row {
      display: flex;
      align-items: center;
      gap: 12px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
    }

    .workflow-stage {
      padding: 6px 14px;
      border-radius: 4px;
      background: var(--surface-2);
      color: var(--text-dim);
      border: 1px solid var(--border);
      white-space: nowrap;
    }

    .workflow-stage.active {
      border-color: var(--green);
      color: var(--green);
    }

    .workflow-stage.human {
      border-color: var(--amber);
      color: var(--amber);
    }

    .workflow-arrow {
      color: var(--text-dim);
      opacity: 0.3;
      flex-shrink: 0;
    }

    .code-filename {
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: var(--text-dim);
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-bottom: none;
      border-radius: 8px 8px 0 0;
      padding: 8px 16px;
      margin-top: 28px;
      display: inline-block;
    }

    .code-filename+pre {
      margin-top: 0;
      border-radius: 0 8px 8px 8px;
    }

    .cta {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 32px;
      margin: 48px 0;
    }

    .cta h3 {
      font-family: 'JetBrains Mono', monospace;
      font-size: 16px;
      font-weight: 500;
      color: #eee;
      margin-bottom: 12px;
    }

    .cta p {
      color: var(--text-dim);
      margin-bottom: 20px;
    }

    .cta p:last-of-type {
      margin-bottom: 0;
    }

    .cta-links {
      display: flex;
      gap: 24px;
      margin-top: 20px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
    }

    .cta-links a {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .footer {
      margin-top: 80px;
      padding-top: 24px;
      border-top: 1px solid var(--border);
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      color: var(--text-dim);
      display: flex;
      justify-content: space-between;
    }

    @media (max-width: 600px) {
      .container {
        padding: 48px 20px 80px;
      }

      h1 {
        font-size: 30px;
      }

      .subtitle {
        font-size: 18px;
      }

      .phase-label {
        min-width: 140px;
      }

      .phase-form {
        display: none;
      }

      .workflow-row {
        flex-wrap: wrap;
      }

      .cta-links {
        flex-direction: column;
        gap: 12px;
      }

      .footer {
        flex-direction: column;
        gap: 8px;
      }
    }
  </style>
</head>

<body>

  <div class="container">

    <div class="logo"><span class="chevron">&gt;</span> delegate</div>

    <h1>The hard problem isn't the agents —<br>it's everything between them</h1>

    <p class="subtitle">What I learned trying to run multiple AI agents on real
      projects, and what I built because of it.</p>

    <p class="date">February 2025</p>

    <!-- ── PHASES ────────────────────────────────── -->

    <h2>How we got here</h2>

    <p>Software engineering has gone through four transitions in rapid
      succession. Each one changed not just how we write code, but where.</p>

    <div class="phases">
      <div class="phase">
        <div class="phase-dot"></div>
        <span class="phase-label">Write code in an IDE</span>
        <span class="phase-form">VS Code, IntelliJ</span>
      </div>
      <div class="phase">
        <div class="phase-dot"></div>
        <span class="phase-label">AI autocompletes lines</span>
        <span class="phase-form">Copilot, early Cursor</span>
      </div>
      <div class="phase">
        <div class="phase-dot"></div>
        <span class="phase-label">Agent in the sidebar</span>
        <span class="phase-form">Cursor, Windsurf</span>
      </div>
      <div class="phase">
        <div class="phase-dot"></div>
        <span class="phase-label">Agent in the terminal</span>
        <span class="phase-form">Claude Code, Codex</span>
      </div>
      <div class="phase">
        <div class="phase-dot"></div>
        <span class="phase-label">Multi-agent teams</span>
        <span class="phase-form">???</span>
      </div>
    </div>

    <p>The first four transitions had a natural home. Autocomplete lives in the
      editor. A sidebar agent lives in the IDE. A terminal agent lives in the
      terminal. But the fifth is different.</p>

    <p>I wanted to run multiple side projects in parallel — have agents working
      on one while I focused on another. When you're running three agents
      simultaneously, you're not editing alongside them. You're
      <strong>managing</strong> them. And the right form factor for managing a
      team isn't an IDE or a terminal.
    </p>

    <p>The obvious answer is tmux — split your terminal into panes, run an agent
      in each one. I tried this. It works until it doesn't. Three agents means
      three panes to watch, with no unified view of what's done, what's stuck,
      and what needs you. You're manually tracking which agent finished, which
      branch to review, which to merge first. There's no shared state between
      them, no way to coordinate handoffs, and when you come back after twenty
      minutes, you're reading scrollback in three panes trying to reconstruct
      what happened. It scales to about two agents before the cognitive overhead
      eats the productivity gain.</p>

    <p>What I needed was a dashboard I could check — delegate work, switch to my
      own editor, glance back when something needed my attention. I also needed
      a server process that could stay alive, manage long-running agent
      sessions, and eventually respond to webhooks. And I wanted to talk to my
      team — voice input is natural for giving instructions and nearly
      impossible in a terminal.</p>

    <!-- ── DISCOVERY: GIT ────────────────────────── -->

    <h2>The first wall: git</h2>

    <p>I started by giving multiple Claude Code instances their own branches and
      letting them work. The agents were fine. They could read code, write
      implementations, run tests. The problem was everything around them.</p>

    <p>Two agents touching the same file. An agent that decided to
      <code>git rebase</code> on its own and corrupted the branch history.
      Worktrees left behind after a crash. Merge conflicts that appeared only
      after both agents had finished. A merge that moved <code>main</code>
      forward while I had uncommitted changes, leaving my working tree in a
      confusing state.
    </p>

    <p>I spent more time in <code>git reflog</code> cleaning up messes than I
      saved by running agents in parallel. The productivity gain was negative.
    </p>

    <p>The solution was isolating agents completely. Each agent works in its own
      git worktree with a dedicated branch, forked from <code>main</code> at the
      moment the task is created. Agents are forbidden from rebasing, merging,
      or checking out branches — enforced at the OS permission level, not just
      in the prompt. Merges happen through a separate process: create a
      temporary branch, rebase onto current <code>main</code>, run the test
      pipeline, fast-forward <code>main</code> in one atomic operation. If
      anything fails, nothing is modified. The repository is never corrupted.
    </p>

    <p>This infrastructure is invisible when it works. But without it,
      multi-agent coding is a liability.</p>

    <!-- ── DISCOVERY: ENVIRONMENT ──────────────────── -->

    <h2>The second wall: environment</h2>

    <p>With git solved, I expected agents to be productive. They weren't —
      because they were all sharing one environment. Agent A installs a
      dependency, Agent B's <code>pip install</code> clobbers it. Agent A runs
      tests, Agent B's test run collides on the same port. Two agents both
      trying to <code>npm install</code> in the same <code>node_modules</code>
      directory. Everything interferes with everything.</p>

    <p>I wanted something simple: each agent develops against its own isolated
      environment — its own virtualenv, its own <code>node_modules</code>, its
      own build artifacts — so they can write code, install dependencies, and
      <strong>run the full test suite</strong> without stepping on each other.
      Running tests matters because I don't want to review a diff that doesn't
      pass tests. The agent should verify its own work before asking me to look
      at it.
    </p>

    <p>This turned out to be surprisingly hard. Git worktrees share a single
      <code>.git</code> directory, which means tools like
      <code>pip install -e .</code> that depend on the repo root get confused.
      Python venvs contain hardcoded absolute paths. Node resolves
      <code>node_modules</code> by walking up the directory tree, so a worktree
      nested inside the repo picks up the wrong one. Every language ecosystem
      has its own assumptions about where it lives, and most of those
      assumptions break when you have five copies of the same repo checked out
      simultaneously.
    </p>

    <p>What I wanted was some sort of auto-setup of an isolated environment for
      the repository which agents can themselves edit and improve as needed.</p>

    <!-- ── DISCOVERY: WORKFLOW ─────────────────────── -->

    <h2>The third wall: workflow</h2>

    <p>Once git and environment isolation were solid, the next problem surfaced.
      An agent finishes coding. Now what? Who reviews it? How do I know it's
      ready? What if the review finds problems — does it go back to the same
      agent? What if I want human approval before anything merges?</p>

    <p>Each project I worked on had slightly different needs. One needed strict
      review. Another was a prototype where I wanted auto-merge. A third needed
      tests to pass before review even started.</p>

    <p>I was rebuilding a different ad-hoc pipeline for every project. What I
      actually needed was a way to define workflows — stages, transitions,
      assignment rules, quality gates — that could vary per project but share
      the same execution engine. And those workflows needed to be able to reach
      external systems: post to Slack when a task is ready for review, create a
      GitHub PR when code is approved, update Linear when a task ships.</p>

    <!-- ── DELEGATE ──────────────────────────────── -->

    <h2>Introducing Delegate</h2>

    <p>Delegate is what came out of all this. It's a browser-based multi-agent
      tool with a configurable workflow engine running against your local git
      repository. You talk to a manager agent who decomposes your request into
      tasks, assigns them to engineering agents, coordinates reviews, and
      orchestrates merges. You review and approve before anything lands on
      <code>main</code>.
    </p>

    <p><strong>Agents are completely independent.</strong> Each agent works in
      its own git worktree on a dedicated branch — isolated filesystem, isolated
      environment. Delegate auto-generates a bash setup script for each repo
      that creates a working environment from scratch — installing dependencies,
      creating virtualenvs, setting up build tools. It works out of the box for
      common project layouts, though it's not foolproof. Agents can iterate on
      the script themselves as they discover what's missing. The script is
      committed to the repo (<code>.delegate/setup.sh</code>), so you can edit
      it directly if needed.</p>

    <pre><span style="color: var(--text-dim);"># install delegate</span>
<strong>$ pip install delegate-ai</strong>

<span style="color: var(--text-dim);"># start delegate, go to the browser and tell your team what to build</span>
<strong>$ delegate start</strong></pre>

    <p>The interaction model is async. Describe what you want built, switch to
      your own editor, come back when the tab says <strong>(2) Delegate</strong>
      — two tasks need your attention. The interface shows what every agent is
      doing in real time — files being read, tests being run, commits being made
      — without flooding you with messages. For the times you need a quick
      terminal command without switching windows, there's <code>/shell</code>.
    </p>

    <p><strong>Workflows are defined in Python.</strong> There are four stage
      types: agent stages (an AI codes), human stages (you review, approve, or
      edit), auto stages (the system merges, deploys, or tests), and terminal
      stages. Each stage declares its possible outcomes, and every outcome maps
      to a transition. Guards block entry until preconditions are met. The
      engine enforces all of it — no LLM can skip a stage or bypass a guard.</p>

    <div class="workflow-diagram">
      <div class="workflow-row">
        <span class="workflow-stage active">Coding</span>
        <span class="workflow-arrow">→</span>
        <span class="workflow-stage human">Review</span>
        <span class="workflow-arrow">→</span>
        <span class="workflow-stage active">Revise</span>
        <span class="workflow-arrow">→</span>
        <span class="workflow-stage">Merging</span>
        <span class="workflow-arrow">→</span>
        <span class="workflow-stage">Done</span>
      </div>
      <div
        style="font-family: 'JetBrains Mono', monospace; font-size: 11px; color: var(--text-dim); margin-top: 12px; display: flex; gap: 24px;">
        <span><span style="color: var(--green);">■</span> agent</span>
        <span><span style="color: var(--amber);">■</span> human</span>
        <span><span style="color: var(--text-dim);">■</span> auto</span>
      </div>
    </div>

    <div class="code-filename">workflow.py</div>
    <pre><span style="color: var(--green);">from</span> delegate.workflow <span style="color: var(--green);">import</span> (
    Workflow, AgentStage, HumanStage, AutoStage, TerminalStage,
    DelegatePicks, HumanAction, DiffViewer,
)

<span style="color: var(--text-dim);"># ── Stages ──────────────────────────────────────────</span>

<span style="color: var(--green);">class</span> Coding(AgentStage):
    outcomes = [<span style="color: var(--amber);">"done"</span>]

    <span style="color: var(--green);">async def</span> assign(self, ctx):
        <span style="color: var(--green);">return</span> DelegatePicks(
            candidates=ctx.team.agents,
            instruction=<span style="color: var(--amber);">"Pick the agent most familiar with this area."</span>,
        )

    <span style="color: var(--green);">def</span> instructions(self, ctx):
        base = <span style="color: var(--amber);">"Implement the changes described in the task brief."</span>
        <span style="color: var(--green);">if</span> ctx.review_comments:
            base += <span style="color: var(--amber);">"\n\nPrevious review feedback:\n"</span>
            <span style="color: var(--green);">for</span> c <span style="color: var(--green);">in</span> ctx.review_comments:
                base += <span style="color: var(--amber);">f"- {c.by}: {c.text}\n"</span>
        <span style="color: var(--green);">return</span> base


<span style="color: var(--green);">class</span> Review(HumanStage):
    outcomes = [<span style="color: var(--amber);">"approved"</span>, <span style="color: var(--amber);">"approved_with_edits"</span>, <span style="color: var(--amber);">"changes_requested"</span>]

    <span style="color: var(--green);">async def</span> assign(self, ctx):
        <span style="color: var(--green);">return</span> DelegatePicks(
            candidates=ctx.team.humans,
            exclude=[ctx.task.assignee],
            instruction=<span style="color: var(--amber);">"Pick a reviewer. Should not be the coder."</span>,
        )

    <span style="color: var(--green);">async def</span> action(self, ctx):
        <span style="color: var(--green);">return</span> HumanAction(
            viewer=DiffViewer(files=ctx.task.changed_files),
            editable=<span style="color: var(--green);">True</span>,     <span style="color: var(--text-dim);"># human can touch up code inline</span>
            comment_enabled=<span style="color: var(--green);">True</span>,
        )

    <span style="color: var(--green);">async def</span> enter(self, ctx):
        <span style="color: var(--green);">if</span> <span style="color: var(--amber);">"slack"</span> <span style="color: var(--green);">in</span> ctx.capabilities:
            <span style="color: var(--green);">await</span> ctx.slack.post(<span style="color: var(--amber);">f"Task {ctx.task.id} ready for review"</span>)


<span style="color: var(--green);">class</span> Merging(AutoStage):
    outcomes = [<span style="color: var(--amber);">"done"</span>, <span style="color: var(--amber);">"conflict"</span>]

    <span style="color: var(--green);">async def</span> guard(self, ctx):
        ci = <span style="color: var(--green);">await</span> ctx.git.get_ci_status(ctx.task.branch)
        <span style="color: var(--green);">return</span> ci.status == <span style="color: var(--amber);">"passing"</span>

    <span style="color: var(--green);">async def</span> action(self, ctx):
        result = <span style="color: var(--green);">await</span> ctx.git.merge(
            repo=ctx.task.repo, branch=ctx.task.branch, into=<span style="color: var(--amber);">"main"</span>,
        )
        <span style="color: var(--green);">return</span> <span style="color: var(--amber);">"conflict"</span> <span style="color: var(--green);">if</span> result.conflict <span style="color: var(--green);">else</span> <span style="color: var(--amber);">"done"</span>


<span style="color: var(--text-dim);"># ── Workflow ─────────────────────────────────────────</span>

engineering = Workflow(
    name=<span style="color: var(--amber);">"engineering"</span>,
    stages=[Coding, Review, Revise, Merging, Done],
    transitions={
        (Coding,  <span style="color: var(--amber);">"done"</span>):                Review,
        (Review,  <span style="color: var(--amber);">"approved"</span>):            Merging,
        (Review,  <span style="color: var(--amber);">"approved_with_edits"</span>): Merging,
        (Review,  <span style="color: var(--amber);">"changes_requested"</span>):  Revise,
        (Revise,  <span style="color: var(--amber);">"done"</span>):                Review,
        (Merging, <span style="color: var(--amber);">"done"</span>):                Done,
        (Merging, <span style="color: var(--amber);">"conflict"</span>):            Review,
    },
    initial=Coding,
)</pre>

    <p>The workflow is a directed graph. Stages define what happens at each step
      — the <code>Review</code> stage shows a diff viewer where you can approve,
      touch up the code inline, or request changes. <code>DelegatePicks</code>
      gives the manager agent a candidate pool and lets it choose who to assign
      based on judgment and workload. Integrations with external systems —
      Slack, GitHub, Linear — are hooks on stage transitions. The workflow
      engine is the core of the product. Agents are workers plugged into it.</p>

    <!-- ── HONEST ────────────────────────────────── -->

    <h2>Where it stands</h2>

    <p>Delegate is in early alpha. It works for single-player local development
      — one human managing a team of AI agents against a local git repository.
      The git orchestration, merge queue, and review pipeline are functional and
      handling real work.</p>

    <p>The workflow API is functional but still evolving. Integrations with
      external systems are designed for but not yet built — the hook points
      exist in the workflow engine, the connectors don't.</p>

    <p>A few things I've learned the hard way:</p>

    <p><strong>Agent quality is a function of context, not just model.</strong>
      A cheaper model with a persistent session often outperforms an expensive
      model with a fresh context window each turn. The agent that remembers
      reading a file doesn't re-read it, doesn't re-derive the architecture, and
      doesn't make contradictory decisions. Per-turn cost is a misleading
      metric. Per-correct-outcome cost is what matters.</p>

    <p><strong>The merge queue is everything.</strong> Without automated rebase,
      pipeline gates, and atomic fast-forward merges, multi-agent development is
      multi-agent chaos. Every bug I've fixed in the merge pipeline has been
      worth ten prompt engineering improvements.</p>

    <p><strong>Reviews catch what prompts miss.</strong> Having a separate agent
      review code with fresh eyes catches bugs the author agent is blind to.
      This doesn't require AI coordination magic — it's the same reason human
      code review works.</p>

    <!-- ── FUTURE ────────────────────────────────── -->

    <h2>What's next</h2>

    <p>Local-first is the foundation, not the ceiling. The workflow engine is
      designed to support hybrid teams — human engineers and AI agents working
      side by side, with configurable workflows that encode each team's process.
      The same stage can be assigned to a person or an agent depending on the
      task.</p>

    <p>I'm particularly interested in what happens when the infrastructure is
      right and the models keep improving. Faster inference means the manager
      responds in seconds, not minutes. Better reasoning means agents produce
      code that passes review on the first try. The infrastructure I'm building
      today — worktree isolation, workflow engine, merge orchestration — becomes
      more valuable as agents get smarter, not less.</p>

    <p>Delegate is MIT licensed and open source.</p>

    <!-- ── CTA ────────────────────────────────────── -->

    <div class="cta">
      <h3>Shape what Delegate becomes</h3>
      <p>I'm looking for early users who want to push on this with me. What
        workflows would you define? What integrations matter most? What's broken
        about multi-agent coding that you wish someone would fix?</p>
      <div class="cta-links">
        <a href="https://github.com/nikhilgarg28/delegate/discussions">↗ Join
          the discussion on GitHub</a>
        <a href="https://github.com/nikhilgarg28/delegate">↗ Browse the
          source</a>
      </div>
    </div>

    <!-- ── FOOTER ────────────────────────────────── -->

    <div class="footer">
      <span>MIT License</span>
      <span class="logo" style="margin-bottom: 0; font-size: 13px;"><span
          class="chevron">&gt;</span> delegate</span>
    </div>

  </div>

  <!-- ── ANALYTICS ──────────────────────────────── -->
  <script data-goatcounter="https://nikhil.goatcounter.com/count" async
    src="//gc.zgo.at/count.js"></script>

</body>

</html>