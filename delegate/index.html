<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Introducing Delegate</title>
  <meta name="description"
    content="Multi-agent software engineering with configurable workflows. Local-first, browser-based, open source.">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Source+Serif+4:ital,opsz,wght@0,8..60,300;0,8..60,400;0,8..60,600;1,8..60,400&display=swap"
    rel="stylesheet">
  <style>
    :root {
      --bg: #141415;
      --surface: #1a1a1c;
      --surface-2: #222224;
      --border: #2a2a2d;
      --text: #cccccd;
      --text-dim: #858587;
      --green: #4ade80;
      --green-dim: #4ade8033;
      --amber: #fbbf24;
      --red: #f87171;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'Source Serif 4', Georgia, serif;
      font-size: 18px;
      line-height: 1.72;
      -webkit-font-smoothing: antialiased;
    }

    .container {
      max-width: 720px;
      margin: 0 auto;
      padding: 80px 24px 120px;
    }

    .logo {
      font-family: 'JetBrains Mono', monospace;
      font-size: 20px;
      font-weight: 500;
      color: var(--green);
      margin-bottom: 64px;
      letter-spacing: -0.02em;
    }

    .logo .chevron {
      opacity: 0.5;
    }

    h1 {
      font-family: 'Source Serif 4', Georgia, serif;
      font-size: 40px;
      font-weight: 600;
      line-height: 1.2;
      color: #eee;
      margin-bottom: 16px;
      letter-spacing: -0.02em;
    }

    .subtitle {
      font-size: 20px;
      color: var(--text-dim);
      margin-bottom: 64px;
      line-height: 1.5;
    }

    .date {
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      color: var(--text-dim);
      margin-bottom: 48px;
    }

    h2 {
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      font-weight: 600;
      color: var(--green);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-top: 72px;
      margin-bottom: 24px;
    }

    p {
      margin-bottom: 24px;
    }

    a {
      color: var(--green);
      text-decoration: none;
    }

    a:hover {
      text-decoration: underline;
    }

    strong {
      color: #eee;
      font-weight: 600;
    }

    code {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85em;
      background: var(--surface-2);
      padding: 2px 7px;
      border-radius: 4px;
    }

    pre {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 20px 24px;
      margin: 28px 0;
      overflow-x: auto;
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      line-height: 1.6;
      color: var(--text-dim);
    }

    pre strong {
      color: var(--text);
      font-weight: 400;
    }

    hr {
      border: none;
      border-top: 1px solid var(--border);
      margin: 64px 0;
    }

    .phases {
      display: flex;
      flex-direction: column;
      gap: 0;
      margin: 40px 0;
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
    }

    .phase {
      display: flex;
      align-items: center;
      gap: 16px;
      padding: 14px 20px;
      border-left: 2px solid var(--border);
      position: relative;
    }

    .phase:last-child {
      border-left-color: var(--green);
    }

    .phase-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--border);
      flex-shrink: 0;
      position: absolute;
      left: -5px;
    }

    .phase:last-child .phase-dot {
      background: var(--green);
      box-shadow: 0 0 8px var(--green-dim);
    }

    .phase-label {
      color: var(--text-dim);
      min-width: 200px;
    }

    .phase:last-child .phase-label {
      color: var(--green);
    }

    .phase-form {
      color: var(--text-dim);
      opacity: 0.5;
    }

    .phase:last-child .phase-form {
      color: var(--text);
      opacity: 1;
    }

    .workflow-diagram {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 32px 24px;
      margin: 32px 0;
      overflow-x: auto;
    }

    .workflow-row {
      display: flex;
      align-items: center;
      gap: 12px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
    }

    .workflow-stage {
      padding: 6px 14px;
      border-radius: 4px;
      background: var(--surface-2);
      color: var(--text-dim);
      border: 1px solid var(--border);
      white-space: nowrap;
    }

    .workflow-stage.active {
      border-color: var(--green);
      color: var(--green);
    }

    .workflow-stage.human {
      border-color: var(--amber);
      color: var(--amber);
    }

    .workflow-arrow {
      color: var(--text-dim);
      opacity: 0.3;
      flex-shrink: 0;
    }

    .code-filename {
      font-family: 'JetBrains Mono', monospace;
      font-size: 12px;
      color: var(--text-dim);
      background: var(--surface-2);
      border: 1px solid var(--border);
      border-bottom: none;
      border-radius: 8px 8px 0 0;
      padding: 8px 16px;
      margin-top: 28px;
      display: inline-block;
    }

    .code-filename+pre {
      margin-top: 0;
      border-radius: 0 8px 8px 8px;
    }

    .cta {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 32px;
      margin: 48px 0;
    }

    .cta h3 {
      font-family: 'JetBrains Mono', monospace;
      font-size: 16px;
      font-weight: 500;
      color: #eee;
      margin-bottom: 12px;
    }

    .cta p {
      color: var(--text-dim);
      margin-bottom: 20px;
    }

    .cta p:last-of-type {
      margin-bottom: 0;
    }

    .cta-links {
      display: flex;
      gap: 24px;
      margin-top: 20px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
    }

    .cta-links a {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .footer {
      margin-top: 80px;
      padding-top: 24px;
      border-top: 1px solid var(--border);
      font-family: 'JetBrains Mono', monospace;
      font-size: 13px;
      color: var(--text-dim);
      display: flex;
      justify-content: space-between;
    }

    @media (max-width: 600px) {
      .container {
        padding: 48px 20px 80px;
      }

      h1 {
        font-size: 30px;
      }

      .subtitle {
        font-size: 18px;
      }

      .phase-label {
        min-width: 140px;
      }

      .phase-form {
        display: none;
      }

      .workflow-row {
        flex-wrap: wrap;
      }

      .cta-links {
        flex-direction: column;
        gap: 12px;
      }

      .footer {
        flex-direction: column;
        gap: 8px;
      }
    }
  </style>
</head>

<body>

  <div class="container">

    <div class="logo"><span class="chevron">&gt;</span> delegate</div>

    <h1>The hard problem isn't the agents —<br>it's everything between them</h1>

    <p class="subtitle">What I learned trying to run multiple AI agents on real
      projects, and what I built because of it.</p>

    <p class="date">February 2025</p>

    <!-- ── PHASES ────────────────────────────────── -->

    <h2>How we got here</h2>

    <p>Software engineering has gone through four transitions in rapid
      succession. Each one changed not just how we write code, but where.</p>

    <div class="phases">
      <div class="phase">
        <div class="phase-dot"></div>
        <span class="phase-label">Write code in an IDE</span>
        <span class="phase-form">VS Code, IntelliJ</span>
      </div>
      <div class="phase">
        <div class="phase-dot"></div>
        <span class="phase-label">AI autocompletes lines</span>
        <span class="phase-form">Copilot, early Cursor</span>
      </div>
      <div class="phase">
        <div class="phase-dot"></div>
        <span class="phase-label">Agent in the sidebar</span>
        <span class="phase-form">Cursor, Windsurf</span>
      </div>
      <div class="phase">
        <div class="phase-dot"></div>
        <span class="phase-label">Agent in the terminal</span>
        <span class="phase-form">Claude Code, Codex</span>
      </div>
      <div class="phase">
        <div class="phase-dot"></div>
        <span class="phase-label">Multi-agent teams</span>
        <span class="phase-form">???</span>
      </div>
    </div>

    <p>The first four transitions had a natural home. Autocomplete lives in the
      editor. A sidebar agent lives in the IDE. A terminal agent lives in the
      terminal. But the fifth is different.</p>

    <p>I wanted to run multiple side projects in parallel — have agents working
      on one while I focused on another. When you're running three agents
      simultaneously, you're not editing alongside them. You're
      <strong>managing</strong> them. What should be the right form factor for
      managing a team of agents?
    </p>

    <p>One obvious answer is tmux — split your terminal into panes, run an agent
      in each one. I tried this. It works until it doesn't. Three agents means
      three panes to watch, with no unified view of what's done, what's stuck,
      and what needs you. You're manually tracking which agent finished, which
      branch to review, which to merge first. There's no shared state between
      them, no way to coordinate handoffs, and when you come back after twenty
      minutes, you're reading scrollback in three panes trying to reconstruct
      what happened. It scales to about two agents before the cognitive overhead
      eats the productivity gain.</p>

    <p>What I needed was a dashboard I could check — delegate work, switch to my
      own editor, glance back when something needed my attention. I also needed
      a server process that could stay alive, manage long-running agent
      sessions, and eventually respond to webhooks.

      <!-- ── DISCOVERY: GIT ────────────────────────── -->

    <h2>The first wall: git</h2>

    <p>I started by giving multiple Claude Code instances their own branches and
      letting them work. The agents were fine. They could read code, write
      implementations, run tests. The problem was everything around them.</p>

    <p>Two agents touching the same file. An agent that decided to
      <code>git rebase</code> on its own and corrupted the branch history.
      Worktrees left behind after a crash. Merge conflicts that appeared only
      after both agents had finished. A merge that moved <code>main</code>
      forward while I had uncommitted changes, leaving my working tree in a
      confusing state.
    </p>

    <p>I spent more time in <code>git reflog</code> cleaning up messes than I
      saved by running agents in parallel. The productivity gain was negative.
    </p>

    <p>The obvious answer is to isolate agents completely in their own
      worktrees and/or branches. This is easier said than done though because
      agents are rather creative and resourceful and may still bypass the
      prompt instructions. So some form of sandboxing is needed to prevent
      agents from being able to do things they shouldn't. Further, come merge
      time,
      all operations need to be atomic and idempotent.
    </p>


    <!-- ── DISCOVERY: ENVIRONMENT ──────────────────── -->

    <h2>The second wall: environment</h2>

    <p>After git, the next problem is environment isolation. Agents are all
      sharing one environment - Agent A's <code>pip install</code> clobbers
      Agent B's
      dependency. Agent A runs tests, Agent B's test run collides on the same
      port. Two agents both trying to <code>npm install</code> in the same
      <code>node_modules</code> directory. Everything interferes with
      everything.
    </p>

    <p>Creating automated environment per agent, unsurprisingly, turned out to
      be hard. Git worktrees share a single <code>.git</code> directory, which
      means tools like <code>pip install -e .</code> that depend on the repo
      root get confused. Python venvs contain hardcoded absolute paths. Node
      resolves <code>node_modules</code> by walking up the directory tree, so a
      worktree nested inside the repo picks up the wrong one. Every language
      ecosystem has its own assumptions about where it lives, and many of those
      assumptions break when you have five copies of the same repo checked out
      simultaneously.
    </p>

    <p>What I wanted was some sort of auto-setup of an isolated environment for
      the repository which agents can themselves edit and improve as needed.</p>

    <!-- ── DISCOVERY: Security ─────────────────────── -->

    <h2>The third wall: security</h2>
    <p>I wans't comfortable with multiple agents running potentially
      unsupervised
      having full access to the machine. What if they were to corrupt my git
      repo?
      Or mistakenly delete my database? Or download malware?
    </p>
    <p>I wanted a reasonable level of sandboxing that prevented them from doing
      harm while still allowing them to do their job. I could run them all in
      a separate docker container and maybe that's the right answer - but I just
      wanted something simpler and lighter weight.
    </p>

    <!-- ── DISCOVERY: WORKFLOW ─────────────────────── -->

    <h2>The fourth wall: workflow</h2>

    <p>Once git and environment isolation were solid, the next problem surfaced.
      An agent finishes coding. Now what? Who reviews it? How do I know it's
      ready? What if the review finds problems — does it go back to the same
      agent? What if I want human approval before anything merges?</p>

    <p>Each project I worked on had slightly different needs. One needed strict
      review. Another was a prototype where I wanted auto-merge. A third needed
      tests to pass before review even started.</p>

    <p>I was rebuilding a different ad-hoc pipeline for every project. What I
      actually needed was a way to define workflows — stages, transitions,
      assignment rules, quality gates — that could vary per project but share
      the same execution engine. And those workflows needed to be able to reach
      external systems: post to Slack when a task is ready for review, create a
      GitHub PR when code is approved, update Linear when a task ships.</p>

    <!-- ── DELEGATE ──────────────────────────────── -->

    <h2>Introducing Delegate</h2>

    <p>Delegate is what came out of all this. It's a browser-based multi-agent
      tool with a configurable workflow engine running against your local git
      repository. You talk to a manager agent who decomposes your request into
      tasks, assigns them to engineering agents, coordinates reviews, and
      orchestrates merges. You review and approve before anything lands on
      <code>main</code>.
    </p>


    <pre><span style="color: var(--text-dim);"># install delegate</span>
<strong>$ pip install delegate-ai</strong>

<span style="color: var(--text-dim);"># start delegate, go to the browser and tell your team what to build</span>
<strong>$ delegate start</strong></pre>

    <!-- I want video to be centered (i.e. go outside the container so far) -->
  </div>


  <video style="margin: 0 auto; display: block; max-width: 100%;" src="https://github.com/user-attachments/assets/5d2f5a8f-8bae-45b7-85c9-53ccb1a47fa3"
    width="80%" controls muted playsinline>
    Your browser does not support the video tag.
  </video>

  <div class="container">
    <h2>Agents have independent git repos</h2>
    <p>Each agent works in its own git worktree on a dedicated branch.
      Permissions are enforced via
      sandbox such that agents can't add/remove worktrees, branches, do rebase,
      reset, etc - all such operations are handled by deterministic Python code.
    </p>

    <h2>Environment is isolated</h2>
    <p>Delegate auto-generates a bash
      setup script for each repo that creates a working environment from scratch
      - installing dependencies, creating virtualenvs, setting up build tools.
      It works out of the box for common project layouts, though it's not
      foolproof.
      Agents can iterate on the script themselves as they discover what's
      missing.
      The script is committed to the repo (<code>.delegate/setup.sh</code>), so
      you
      can edit it directly if needed.
    </p>

    <h2>Agents run in a secured sandbox</h2>
    <p>Agents are run in a
      secured sandbox that limits write access to either delegate's own folders,
      temp directory or project's .git directory (but importantly, not the
      working
      directory). As a result, they can either write to delegate manager
      worktrees
      or your project's .git folder. Further, they are disallowed from running
      git
      operations that mutate the branch topology (e.g. rebase, merge, reset,
      etc)
      so even with access to the .git folder, they cannot corrupt the project.

      The network access is also limited to a allowlist of domains (default
      being
      common package managers and git forges) and can be further customized via
      CLI.
    </p>


    <h2>The interaction model is async</h2>
    <p>Describe what you want
      built, switch to your own editor, come back when the tab says <strong>(2)
        Delegate</strong> — two tasks need your attention. The interface shows
      what every agent is doing in real time — files being read, tests being
      run, commits being made — without flooding you with messages. For the
      times you need a quick terminal command without switching windows,
      there's <code>/shell</code>.
    </p>

    <h2>Delegate is GUI based</h2>
    <p>Even though I love being in the
      terminal, I have come to believe that such an async model requires one to
      observe
      many agents live which requires deeper UI capabilities than a terminal can
      provide. I have bundled a PWA for native app experience but hope to make
      a real native app (using Tauri?) at some point.
    </p>

    <h2>Workflows are defined in Python</h2>
    <p>The workflow API is early and actively evolving. Currently, it hardcodes
      the "standard" workflow - coding, peer review, approval, revise, merge.
      From here on, I want to evolve the workflow API to be more flexible and
      powerful.

    <div class="workflow-diagram">
      <div class="workflow-row">
        <span class="workflow-stage active">Coding</span>
        <span class="workflow-arrow">→</span>
        <span class="workflow-stage active">Peer Agent Review</span>
        <span class="workflow-arrow">→</span>
        <span class="workflow-stage human">Approval</span>
        <span class="workflow-arrow">→</span>
        <span class="workflow-stage active">Revise</span>
        <span class="workflow-arrow">→</span>
        <span class="workflow-stage">Merge</span>
      </div>
      <div
        style="font-family: 'JetBrains Mono', monospace; font-size: 11px; color: var(--text-dim); margin-top: 12px; display: flex; gap: 24px;">
        <span><span style="color: var(--green);">■</span> agent</span>
        <span><span style="color: var(--amber);">■</span> human</span>
        <span><span style="color: var(--text-dim);">■</span> auto</span>
      </div>
    </div>


    <!-- ── HONEST ────────────────────────────────── -->

    <h2>Where it stands</h2>

    <p>Delegate is in early alpha. It works for single-player local development
      — one human managing a team of AI agents against a local git repository.
      The git orchestration, merge queue, and review pipeline are functional and
      handling real work.</p>

    <p>The workflow API is functional but still evolving. Integrations with
      external systems are designed for but not yet built — the hook points
      exist in the workflow engine, the connectors don't. Environment setup
      works for some common cases but needs to become lot more robust.

    <p>A few things I've learned the hard way:</p>

    <p><strong>Agent quality is a function of context, not just model.</strong>
      A cheaper model with a persistent session often outperforms an expensive
      model with a fresh context window each turn. The agent that remembers
      reading a file doesn't re-read it, doesn't re-derive the architecture, and
      doesn't make contradictory decisions. Per-turn cost is a misleading
      metric. Per-correct-outcome cost is what matters.</p>

    <p><strong>The merge queue is everything.</strong> Without automated rebase,
      pipeline gates, and atomic fast-forward merges, multi-agent development is
      multi-agent chaos. Every bug I've fixed in the merge pipeline has been
      worth ten prompt engineering improvements.</p>

    <p><strong>Peer reviews catch what prompts miss.</strong> Having a separate
      peer agent review code with fresh eyes catches bugs the author agent is
      blind to.
      This doesn't require AI coordination magic — it's the same reason human
      code review works.</p>

    <!-- ── FUTURE ────────────────────────────────── -->

    <h2>What's next</h2>

    <p>Local-first is the foundation, not the ceiling. The workflow engine is
      designed to support hybrid teams — human engineers and AI agents working
      side by side, with configurable workflows that encode each team's process.
      The same stage can be assigned to a person or an agent depending on the
      task.</p>

    <p>I'm particularly interested in what happens when the infrastructure is
      right and the models keep improving. Faster inference means the manager
      responds in seconds, not minutes. Better reasoning means agents produce
      code that passes review on the first try. The infrastructure I'm building
      today — worktree isolation, workflow engine, merge orchestration — becomes
      more valuable as agents get smarter, not less.</p>

    <p>Delegate is MIT licensed and open source.</p>

    <!-- ── CTA ────────────────────────────────────── -->

    <div class="cta">
      <h3>Shape what Delegate becomes</h3>
      <p>I'm looking for early users who want to push on this with me. What
        workflows would you define? What integrations matter most? What's broken
        about multi-agent coding that you wish someone would fix?</p>
      <div class="cta-links">
        <a href="https://github.com/nikhilgarg28/delegate/discussions">↗ Join
          the discussion on GitHub</a>
        <a href="https://github.com/nikhilgarg28/delegate">↗ Browse the
          source</a>
      </div>
    </div>

    <!-- ── FOOTER ────────────────────────────────── -->

    <div class="footer">
      <span>MIT License</span>
      <span class="logo" style="margin-bottom: 0; font-size: 13px;"><span
          class="chevron">&gt;</span> delegate</span>
    </div>

  </div>

  <!-- ── ANALYTICS ──────────────────────────────── -->
  <script data-goatcounter="https://nikhil.goatcounter.com/count" async
    src="//gc.zgo.at/count.js"></script>

</body>

</html>